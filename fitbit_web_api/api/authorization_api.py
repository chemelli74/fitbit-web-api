"""
Fitbit Web API Explorer

Fitbit provides a Web API for accessing data from Fitbit activity trackers, Aria scale, and manually entered logs. Anyone can develop an application to access and modify a Fitbit user's data on their behalf, so long as it complies with Fitbit Platform Terms of Service. These Swagger UI docs do not currently support making Fitbit API requests directly. In order to make a request, construct a request for the appropriate endpoint using this documentation, and then add an Authorization header to each request with an access token obtained using the steps outlined here: https://dev.fitbit.com/build/reference/web-api/developer-guide/authorization/.

The version of the OpenAPI document: 1
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import Field, StrictFloat, StrictInt, StrictStr, validate_call
from typing_extensions import Annotated

from fitbit_web_api.api_client import ApiClient, RequestSerialized
from fitbit_web_api.api_response import ApiResponse
from fitbit_web_api.rest import RESTResponseType


class AuthorizationApi:
    """
    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    async def introspect(
        self,
        token: Annotated[
            StrictStr, Field(description="OAuth 2.0 token to retrieve the state of")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """
        Retrieve the active state of an OAuth 2.0 token

        Retrieves the active state of an OAuth 2.0 token. It follows https://tools.ietf.org/html/rfc7662.

        :param token: OAuth 2.0 token to retrieve the state of (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._introspect_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def introspect_with_http_info(
        self,
        token: Annotated[
            StrictStr, Field(description="OAuth 2.0 token to retrieve the state of")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """
        Retrieve the active state of an OAuth 2.0 token

        Retrieves the active state of an OAuth 2.0 token. It follows https://tools.ietf.org/html/rfc7662.

        :param token: OAuth 2.0 token to retrieve the state of (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._introspect_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def introspect_without_preload_content(
        self,
        token: Annotated[
            StrictStr, Field(description="OAuth 2.0 token to retrieve the state of")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """
        Retrieve the active state of an OAuth 2.0 token

        Retrieves the active state of an OAuth 2.0 token. It follows https://tools.ietf.org/html/rfc7662.

        :param token: OAuth 2.0 token to retrieve the state of (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._introspect_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _introspect_serialize(
        self,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(("token", token))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["oauth2"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/1.1/oauth2/introspect",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def oauth_token(
        self,
        client_id: Annotated[
            StrictStr,
            Field(
                description="This is your Fitbit API application id from your settings on dev.fitbit.com."
            ),
        ],
        grant_type: Annotated[
            StrictStr,
            Field(
                description="Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'."
            ),
        ],
        authorization: Annotated[
            Optional[StrictStr],
            Field(
                description="The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'."
            ),
        ] = None,
        code: Annotated[
            Optional[StrictStr],
            Field(
                description="Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow."
            ),
        ] = None,
        expires_in: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour."
            ),
        ] = None,
        redirect_uri: Annotated[
            Optional[StrictStr],
            Field(
                description="Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match."
            ),
        ] = None,
        refresh_token: Annotated[
            Optional[StrictStr],
            Field(
                description="Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'."
            ),
        ] = None,
        state: Annotated[
            Optional[StrictStr],
            Field(
                description="Required if specified in the redirect uri of the authorization page. Must be an exact match."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """
        Get OAuth 2 access token

        Retrieves an OAuth 2 access token.

        :param client_id: This is your Fitbit API application id from your settings on dev.fitbit.com. (required)
        :type client_id: str
        :param grant_type: Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'. (required)
        :type grant_type: str
        :param authorization: The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'.
        :type authorization: str
        :param code: Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow.
        :type code: str
        :param expires_in: Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour.
        :type expires_in: str
        :param redirect_uri: Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match.
        :type redirect_uri: str
        :param refresh_token: Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'.
        :type refresh_token: str
        :param state: Required if specified in the redirect uri of the authorization page. Must be an exact match.
        :type state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        _param = self._oauth_token_serialize(
            client_id=client_id,
            grant_type=grant_type,
            authorization=authorization,
            code=code,
            expires_in=expires_in,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            state=state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def oauth_token_with_http_info(
        self,
        client_id: Annotated[
            StrictStr,
            Field(
                description="This is your Fitbit API application id from your settings on dev.fitbit.com."
            ),
        ],
        grant_type: Annotated[
            StrictStr,
            Field(
                description="Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'."
            ),
        ],
        authorization: Annotated[
            Optional[StrictStr],
            Field(
                description="The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'."
            ),
        ] = None,
        code: Annotated[
            Optional[StrictStr],
            Field(
                description="Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow."
            ),
        ] = None,
        expires_in: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour."
            ),
        ] = None,
        redirect_uri: Annotated[
            Optional[StrictStr],
            Field(
                description="Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match."
            ),
        ] = None,
        refresh_token: Annotated[
            Optional[StrictStr],
            Field(
                description="Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'."
            ),
        ] = None,
        state: Annotated[
            Optional[StrictStr],
            Field(
                description="Required if specified in the redirect uri of the authorization page. Must be an exact match."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """
        Get OAuth 2 access token

        Retrieves an OAuth 2 access token.

        :param client_id: This is your Fitbit API application id from your settings on dev.fitbit.com. (required)
        :type client_id: str
        :param grant_type: Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'. (required)
        :type grant_type: str
        :param authorization: The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'.
        :type authorization: str
        :param code: Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow.
        :type code: str
        :param expires_in: Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour.
        :type expires_in: str
        :param redirect_uri: Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match.
        :type redirect_uri: str
        :param refresh_token: Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'.
        :type refresh_token: str
        :param state: Required if specified in the redirect uri of the authorization page. Must be an exact match.
        :type state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        _param = self._oauth_token_serialize(
            client_id=client_id,
            grant_type=grant_type,
            authorization=authorization,
            code=code,
            expires_in=expires_in,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            state=state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def oauth_token_without_preload_content(
        self,
        client_id: Annotated[
            StrictStr,
            Field(
                description="This is your Fitbit API application id from your settings on dev.fitbit.com."
            ),
        ],
        grant_type: Annotated[
            StrictStr,
            Field(
                description="Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'."
            ),
        ],
        authorization: Annotated[
            Optional[StrictStr],
            Field(
                description="The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'."
            ),
        ] = None,
        code: Annotated[
            Optional[StrictStr],
            Field(
                description="Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow."
            ),
        ] = None,
        expires_in: Annotated[
            Optional[StrictStr],
            Field(
                description="Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour."
            ),
        ] = None,
        redirect_uri: Annotated[
            Optional[StrictStr],
            Field(
                description="Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match."
            ),
        ] = None,
        refresh_token: Annotated[
            Optional[StrictStr],
            Field(
                description="Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'."
            ),
        ] = None,
        state: Annotated[
            Optional[StrictStr],
            Field(
                description="Required if specified in the redirect uri of the authorization page. Must be an exact match."
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """
        Get OAuth 2 access token

        Retrieves an OAuth 2 access token.

        :param client_id: This is your Fitbit API application id from your settings on dev.fitbit.com. (required)
        :type client_id: str
        :param grant_type: Authorization grant type. Valid values are 'authorization_code' and 'refresh_token'. (required)
        :type grant_type: str
        :param authorization: The Authorization header must be set to 'Basic' followed by a space, then the Base64 encoded string of your application's client id and secret concatenated with a colon. For example, 'Basic Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ='. The Base64 encoded string, 'Y2xpZW50X2lkOmNsaWVudCBzZWNyZXQ=', is decoded as 'client_id:client secret'.
        :type authorization: str
        :param code: Authorization code received in the redirect as URI parameter. Required if using the Authorization Code flow.
        :type code: str
        :param expires_in: Specify the desired access token lifetime. Defaults to 28800 for 8 hours. The other valid value is 3600 for 1 hour.
        :type expires_in: str
        :param redirect_uri: Uri to which the access token will be sent if the request is successful. Required if specified in the redirect to the authorization page. Must be exact match.
        :type redirect_uri: str
        :param refresh_token: Refresh token issued by Fitbit. Required if 'grant_type' is 'refresh_token'.
        :type refresh_token: str
        :param state: Required if specified in the redirect uri of the authorization page. Must be an exact match.
        :type state: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501
        _param = self._oauth_token_serialize(
            client_id=client_id,
            grant_type=grant_type,
            authorization=authorization,
            code=code,
            expires_in=expires_in,
            redirect_uri=redirect_uri,
            refresh_token=refresh_token,
            state=state,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
            "401": None,
            "409": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _oauth_token_serialize(
        self,
        client_id,
        grant_type,
        authorization,
        code,
        expires_in,
        redirect_uri,
        refresh_token,
        state,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if code is not None:

            _query_params.append(("code", code))

        if client_id is not None:

            _query_params.append(("client_id", client_id))

        if expires_in is not None:

            _query_params.append(("expires_in", expires_in))

        if grant_type is not None:

            _query_params.append(("grant_type", grant_type))

        if redirect_uri is not None:

            _query_params.append(("redirect_uri", redirect_uri))

        if refresh_token is not None:

            _query_params.append(("refresh_token", refresh_token))

        if state is not None:

            _query_params.append(("state", state))

        # process the header parameters
        if authorization is not None:
            _header_params["Authorization"] = authorization
        # process the form parameters
        # process the body parameter

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/oauth2/token",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def revoke(
        self,
        token: Annotated[
            StrictStr,
            Field(description="The access token or refresh token to be revoked"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """
        Revokes consent of the access token or refresh token

        Revokes consent of the access token or refresh token

        :param token: The access token or refresh token to be revoked (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._revoke_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    async def revoke_with_http_info(
        self,
        token: Annotated[
            StrictStr,
            Field(description="The access token or refresh token to be revoked"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """
        Revokes consent of the access token or refresh token

        Revokes consent of the access token or refresh token

        :param token: The access token or refresh token to be revoked (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._revoke_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    async def revoke_without_preload_content(
        self,
        token: Annotated[
            StrictStr,
            Field(description="The access token or refresh token to be revoked"),
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """
        Revokes consent of the access token or refresh token

        Revokes consent of the access token or refresh token

        :param token: The access token or refresh token to be revoked (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """
        _param = self._revoke_serialize(
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": None,
            "400": None,
        }
        response_data = await self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _revoke_serialize(
        self,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if token is not None:
            _form_params.append(("token", token))
        # process the body parameter

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/x-www-form-urlencoded"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["oauth2"]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/oauth2/revoke",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
